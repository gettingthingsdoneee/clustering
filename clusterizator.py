# -*- coding: utf-8 -*-
"""Информатика_Вариант5_2024_ipynb___.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iHGjI6h_UKoM-M5_Ntx2Tz6X5pSG-oh3

#1) Введение

##2) Характеристики набора данных

В наборе данных представлна информация об оценке покупательской привлекатеольности автомобилей.

Характеристика |	Описание
--- | ---
Byuing |	Успешность продаж
Maintetance |	Уровень сервисного обслуживания
Door |	Количество дверей
Persons |	Количество посадочных мест
Luggage |	Объём багажника
Safety |	Безопасность
Quality | Покупательская привлекательность

## 3) Задание

Построить классификатор, позволяющий отнести автомобиль к одному из классов покупательской привлекательности. Целевой признак находится в столбце Quality.

## 4) Загрузка данных

Загрузить набор данных CarEval.xlsx в сесионное хранилище.
Создать DataFrame Pandas. Имена столбцов взять из первой строки файла.
"""

from google.colab import drive
drive.mount('/content/drive')
#Импортировать библиотеку pandas
import pandas as pd

#Ваш код для загрузки набора данных и создания объекта DataFrame
CarEval_df = pd.read_csv('/content/drive/MyDrive/CarEval.csv')
#CarEval_df = pd.DataFrame(data)

#Вывести 5 первых строк набора данных
CarEval_df.head(5)

"""## 5) Изучение набора данных

#5.1) Определение типов столбцов
"""

#Ваш код для вывода информации о типах столбцов
CarEval_df.info()

"""# 5.2) Проверка наличия отсутствующих значений"""

#Ваш код для проверки наличия пропущенных значений.
CarEval_df.isnull().sum()

"""#5.3) Заполнение отсутствующих значений или удаление строк с отсутсвующими значениями

Пункт выполняется если в наборе данныъ есть отсутствующие значения
"""

#Ваш код для заполнения отсутствующих значений, при необходимости.

"""## 5.4) Изучение статистических показателей набора данных"""

#Ваш код для вывода статистическаих характеристик набора данных.
CarEval_df.describe()

"""#Выводы по разделу 5
Набор данных содержит 1728 записей с 7 столбцами, из которых 2 столбца имеют тип int64, а 5 - тип object.
Отсутствующих значений в наборе данных не обнаружено, что позволяет использовать его для обучения модели.
Статистические показатели для столбцов Door и Persons можно использовать для построения классификатора. Данные других столбцов нужно заменить на числовые, для того чтобы их можно было использовать для построения классификатора.

## 6) Предваритиельная обработка данных

Замена текстовых признаков на числовые.
Обозначьте все текстовые значения признаков числами и выполните замену текстовых значений на числовые.
"""

#Ваш код для замены признака
CarEval_df['Buying'] = CarEval_df['Buying'].map({'vhigh': 0, 'high': 1, 'med': 2, 'low': 3})

#Ваш код для замены признака
CarEval_df['Maintenance'] = CarEval_df['Maintenance'].map({'vhigh': 0, 'high': 1, 'med': 2, 'low': 3})

#Ваш код для замены признака
CarEval_df['Luggage'] = CarEval_df['Luggage'].map({'small': 0, 'med': 1, 'big': 2})

#Ваш код для замены признака
CarEval_df['Safety'] = CarEval_df['Safety'].map({'low': 0, 'med': 1, 'high': 2})

#Ваш код для замены признака
CarEval_df['Quality'] = CarEval_df['Quality'].map({'unacc': 0, 'acc': 1, 'good': 2, 'vgood':3})

#Ваш код для замены признака

#Ваш код для замены признака

#Ваш код для замены признака

#Ваш код для замены признака

#Ваш код для замены признака

#Ваш код для замены признака

#Ваш код для замены признака

#Ваш код для замены признака

#Ваш код для замены признака

#Ваш код для замены признака

#Ваш код для замены признака

#Ваш код для замены признака

#Ваш код для замены признака

#Ваш код для замены признака

#Ваш код для замены признака

#Ваш код для замены признака

#Выведите информацию о типах столбцов после выполненных замен.

"""# 7) Исследовательский анализ данных

# 7.1) Анализ корреляционной матрицы
"""

#Ваш од для формирования корреляционной матрицы
cor_model = CarEval_df.corr(numeric_only=True)
cor_model

"""# Выводы по разделу 7
Из анализа корреляционной матрицы видно, что целевой признак Quality имеет наибольшую корреляцию с признаками Persons, Safety и Luggage. Это означает, что при построении классификатора необходимо уделить особое внимание этим признакам, так как они имеют наибольшее влияние на привлекательность автомобиля для покупателя. Также важными признаками являются Buying и Maintenance, которые также имеют некоторое влияние на Quality. Признак Door имеет наименьшее влияние на качество автомобиля с точки зрения покупателя и может быть менее значим при построении классификатора.

## 8) Визуализация данных

Выбрать 3 **существенные** признаки.

Под **существенным** будем понимать признак, коэффициент корреляции которого с целевым признаком превышает по абсолютной величине 0.22. Если таких признаков нет, считать существенными все признаки.

Построить "Violine plot" для каждого из существенных признаков с группировкой по целевому признаку.
"""

#Импортировать библиотеку seaborn
import seaborn as sns

#Ваш код для первого графика
sns.violinplot(x=CarEval_df['Buying'], y=CarEval_df['Quality'])

#Ваш код для второго графика
sns.violinplot(x=CarEval_df['Persons'], y=CarEval_df['Quality'])

#Ваш код для третьего графика
sns.violinplot(x=CarEval_df['Safety'], y=CarEval_df['Quality'])

"""Построить парный график для анализируемого набора данных."""

#Ваш код для построения парного графика
sns.pairplot(CarEval_df)

"""Построить тепловую диаграмму для анализируемого набора данных."""

#Построить тепловую диаграмму
sns.heatmap(cor_model)

"""#Выводы по разделу 8
В разделе 7 мы предположили, что существенными являюся признаки "Buying", "Persons", "Safety". С помощью графиков, мы убедились, что целевой признак Quality действительно зависит от этих признаков(см.Тепловую диаграмму)

# 9) Подготова данных для обучения

Сформировать обучающий набор данных, удалив из текущего набора данных признак Qual.

Целевой признак в набор обучающих данных не включается.

Сформировать набор данных, состоящий из целевого признака.
"""

#Ваш код для формирования указанных наборов данных
Edu_df = CarEval_df.drop(columns=['Quality'])

Quality_df = CarEval_df['Quality']

"""## 9.1 Выполнить нормализацию данных для набора существенных признаков."""

#Импортировать библиотеку preprocessing
from sklearn import preprocessing
from sklearn.preprocessing import MinMaxScaler

#Ваш код для выполнения нормализации данных
scaler = MinMaxScaler()
Important_df = CarEval_df.drop(columns=['Maintenance', 'Door', 'Luggage', 'Quality'])
Important_df = scaler.fit_transform(Important_df)

"""## 9.2) Разделение набора данных

Разделить обучающий и целевой наборы данных на обучающую и тестовую выборки
"""

#Импортировать библиотеку train_test_split
from sklearn.model_selection import train_test_split

#Ваш код для разделения набора данных на обучающую и тестовую выборки
train_test, check_test, train_ans, check_ans = train_test_split(Edu_df,Quality_df,  stratify=Quality_df, random_state=42, test_size=0.2)
#тренировочный набор, тестирующий набор, ответы на тренировку, ответы на тест

"""# 10) Обучение модели

Обучить модель "Дерево решений".
"""

#Импортировать библиотеку DecisionTreeClassifier
from sklearn.tree import DecisionTreeClassifier

#Создать объект классификатора "Дерево решений"
clf = DecisionTreeClassifier()

#Обучить классификатор
clf.fit(train_test, train_ans)

#Импортировать библиотеку tree
from sklearn import tree

#Импортировать библиотеку matplotlib.pyplot, присвоить ей имя plt
import matplotlib.pyplot as plt

#Выполнить следующий оператор для подготовки поля рисунка
plt.figure(figsize=(30,10), facecolor ='k')

#Постройте рисунок дерева решений, используя метод tree.plot_tree
tree.plot_tree(clf)

"""## 10) Оценка качества модели

Вычислить прогнозные значения для тестового набора данных.
"""

#Ваш код для вычисления прогрнозных значений
pred_ans = clf.predict(check_test)
print(pred_ans)
print(check_ans.to_list())

#Импортировать библиотеки confusion_matrix, precision_score, recall_score, f1_score
from sklearn.metrics import confusion_matrix, precision_score, recall_score, f1_score

#Ваш код для вычисления матрицы несоответствий
check = confusion_matrix(check_ans, pred_ans)
from sklearn.metrics import ConfusionMatrixDisplay
disp = ConfusionMatrixDisplay(confusion_matrix=check, display_labels=clf.classes_)
disp.plot()

#Ваш код для вычисления precision score
print(precision_score(check_ans, pred_ans, average=None))
print("ACCURANCY: ", precision_score(check_ans, pred_ans, average='weighted'))

#Ваш код для вычисления recall score
print(recall_score(check_ans, pred_ans, average=None))
print("ACCURANCY: ", recall_score(check_ans, pred_ans, average='weighted'))

#Ваш код для вычисления f1 score
print(f1_score(check_ans, pred_ans, average=None))
print("ACCURANCY: ", f1_score(check_ans, pred_ans, average='weighted'))



"""#Выводы по разделу 10
Классификатор получился отличным, т.к. точность составляет более 97%
"""